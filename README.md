# Тестовое задание в Lesta на позицию стажера
## Первое задание
### Описание
Написать алгоритм (функцию) определения четности целого числа который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути. Объяснить плюсы и минусы обеих реализаций. 

Пример: 
```python
def isEven(value):

      return value % 2 == 0
```

В моей реализации используется побитовое "И"(&). Четность числа можно определить по последнему биту:

- Если он равен единице - число нечетное
- Если нулю - четное

Исходя из этого, сравнивая число с единицей с помощью &, мы получаем последний бит, а после приводим его к булевому значению

Плюсы:

- Побитовые операции обычно выполняются быстрее чем арифметические(хотя на современном железе разница будет __минимальной__)
- Такой код выглядит лаконично

Минусы:

- Менее читаемая запись, в сравнении с `if value % 2 == 0`

## Второе задание
### Описание
На языке Python написать минимум по 2 класса реализовывающих циклический буфер FIFO. Объяснить плюсы и минусы каждой реализации.

### CircularBufferList. Использование списка и двух указателей.
Плюсы:

- Можно контролировать размер буфера и получать доступ к элементам по индексу
- Более явный контроль буфера через указатели `head` и `tail`

Минусы:

- Необходимо вручную управлять указателями и проверками переполнения
- Может быть медленнее для больших буферов из-за частых модульных операций
- Управление указателями неопытным пользователем может приводить к поломке логики и ошибкам

### CircularBufferDeque. Использования деки из `collections.deque`.
Плюсы:

- Простота реализации, так как `deque` уже предоставляет все необходимые методы
- Быстродействие за счет оптимизаций на добавление в начало и конец
- Меньше кода, так как многие операции уже реализованы (append, popleft)

Минусы:

- Меньше контроля над внутренней реализацией
- Использование внешней библиотеки

## Третье задание
### Описание
На языке Python предложить алгоритм, который быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел. Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным). Объяснить, почему вы считаете, что функция соответствует заданным критериям.
### Объяснение
Несмотря на то, что в худшем случае алгоритм QuickSort имеет сложность _О(n^2)_, усредненная сложность равна _O(n log n)_. Поскольку <u>_массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным)_</u>, QuickSort является одним из наилучших вариантов на таких данных.

Плюсы:
- Быстрое среднее время выполнения
- Простой и легко реализуемый

Минусы:
- Может занимать много памяти при глубокой рекурсии
- В худшем случае медленнее других алгоритмов


